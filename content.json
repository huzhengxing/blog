{"meta":{"title":"爱折腾的Albert","subtitle":null,"description":null,"author":"Albert","url":"https://www.huzhengxing.com","root":"/"},"pages":[{"title":"","date":"2019-11-15T06:36:31.441Z","updated":"2019-11-15T06:34:31.304Z","comments":true,"path":"baidu_verify_TZrI09FYvF.html","permalink":"https://www.huzhengxing.com/baidu_verify_TZrI09FYvF.html","excerpt":"","text":"TZrI09FYvF"},{"title":"关于我","date":"2019-11-12T01:29:53.000Z","updated":"2019-11-20T07:23:57.286Z","comments":true,"path":"about/index.html","permalink":"https://www.huzhengxing.com/about/index.html","excerpt":"","text":"个人介绍我叫胡正兴，来自安徽安庆，现在在杭州定居。现在主要从事互联网和物联网行业中。"},{"title":"分类","date":"2019-11-12T01:30:07.000Z","updated":"2019-11-12T02:00:16.818Z","comments":true,"path":"categories/index.html","permalink":"https://www.huzhengxing.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-12T01:29:56.000Z","updated":"2019-11-12T01:59:53.023Z","comments":true,"path":"tags/index.html","permalink":"https://www.huzhengxing.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Socket通信","slug":"Socket通信","date":"2019-12-06T10:00:00.000Z","updated":"2019-12-14T07:52:24.781Z","comments":true,"path":"2019/12/06/Socket通信/","link":"","permalink":"https://www.huzhengxing.com/2019/12/06/Socket%E9%80%9A%E4%BF%A1/","excerpt":"","text":"1. Socket维基百科: 系统内部接口（内部网络），接口描述符（抽象接口描述符）和接口地址之间的差别其实很细微，日常编程用的时候几乎不做区别。并且详细的网络接口有下面几种特征： 本地接口地址，由本地ip地址和（包括TCP，UDP）端口号 传输协议，例如TCP、UDP、raw IP协议，如果只是指定IP地址，那么TCP 53与UDP 53不是一个接口。 一个已经创建连接的接口双方都有整数形式的接口描述符，用来唯一表示该接口。操作系统根据对方接口发过来的IP以及传输协议头信息来提取接口的地址信息，并且将应用数据去除头信息之后提交给相应的应用程序。 在很多网络协议、教科书以及本文中，接口指的是有一个独一无二的接口号的实体。在一些其他的文章[来源请求]当中，接口被叫做本地接口地址，比如…”ip和端口的结合”。在一RFC147标准中，这个定义与1971的ARPA网有关，接口指的是一个32位数字，其中偶数的是接收接口，奇数的是发送接口，但是今天通信已经可以实现双向传输，在一个接口中，可以发送的同时还可以接收。 在类UNIX系统和Windows系统，命令行工具netstat和ss可用以查看当前系统的接口情况。 2. TCP百度: 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 [1] 定义。 TCP旨在适应支持多网络应用的分层协议层次结构。 连接到不同但互连的计算机通信网络的主计算机中的成对进程之间依靠TCP提供可靠的通信服务。TCP假设它可以从较低级别的协议获得简单的，可能不可靠的数据报服务。 原则上，TCP应该能够在从硬线连接到分组交换或电路交换网络的各种通信系统之上操作。 特点: 面向连接 通过流传输 三次握手，四次挥手 效率低 2.1 TCP服务端12345678910111213141516public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(3333); //获取客户端字节流 Socket accept = serverSocket.accept(); InputStream inputStream = accept.getInputStream(); byte[] bytes = new byte[1024]; int read = inputStream.read(bytes); String message = new String(bytes, 0, read); System.out.println(\"接收到客户端发送的消息:\" + message); serverSocket.close(); &#125;&#125; 2.2 TCP客户端12345678910public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"localhost\", 3333); OutputStream outputStream = socket.getOutputStream(); String message = \"客户端发送消息\"; outputStream.write(message.getBytes()); outputStream.close(); &#125;&#125; 3. UDP百度: Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。RFC 768 [1] 描述了 UDP。 Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。面向连接的是 TCP，该协议几乎做了所有的事情。 特点: 面向无连接 不可靠 传输快，效率高 3.1 UDP服务端1234567891011121314public class UDPServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"UDP服务器开启。。。\"); //开启一个udp服务器 DatagramSocket datagramSocket = new DatagramSocket(2222); byte[] bytes = new byte[1024]; DatagramPacket datagramPacket = new DatagramPacket(bytes, bytes.length); //接收客户端发送的消息 处于阻塞状态 System.out.println(\"等待客户端发送消息。。。\"); datagramSocket.receive(datagramPacket); System.out.println(\"接收服务端发送的消息:\" + new String(datagramPacket.getData(),0,datagramPacket.getLength())); datagramSocket.close(); &#125;&#125; 3.2 UDP客户端12345678910public class UDPClient &#123; public static void main(String[] args) throws IOException &#123; DatagramSocket datagramSocket = new DatagramSocket(); String message = \"客户端发送的消息。。。\"; byte[] bytes = message.getBytes(); DatagramPacket datagramPacket = new DatagramPacket(bytes, 0, bytes.length, InetAddress.getByName(\"localhost\"), 2222); datagramSocket.send(datagramPacket); datagramSocket.close(); &#125;&#125;","categories":[{"name":"socket","slug":"socket","permalink":"https://www.huzhengxing.com/categories/socket/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://www.huzhengxing.com/tags/socket/"},{"name":"java","slug":"java","permalink":"https://www.huzhengxing.com/tags/java/"}]},{"title":"Java线程","slug":"线程学习","date":"2019-11-22T10:00:00.000Z","updated":"2019-11-23T07:36:57.176Z","comments":true,"path":"2019/11/22/线程学习/","link":"","permalink":"https://www.huzhengxing.com/2019/11/22/%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1. 什么是线程维基百科 线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。 线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。 一个进程可以有很多线程，每条线程并行执行不同的任务。 在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见的，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。 线程是系统运算调度的最小单位。 一个进程中多个线程组成。 2. Java线程状态线程从创建、运行到结束总是处于下面六个状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED。 Tread内部类State说明: NEW 123/** * Thread state for a thread which has not yet started. */ 初始状态:当一个线程创建，还没有调用start()方法时。 RUNNABLE 123456/** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ 可运行状态:一个线程正在运行，或者等待被其他资源调用。 BLOCKED 1234567/** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * &#123;@link Object#wait() Object.wait&#125;. */ 阻塞状态:在线程中加入synchronized。 WAITING 12345678910111213141516171819/** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * &lt;ul&gt; * &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt; * on an object is waiting for another thread to call * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt; * is waiting for a specified thread to terminate. */ TIMED_WAITING 123456789101112/** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * &lt;ul&gt; * &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt; * &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt; * &lt;/ul&gt; */ TERMINATED 1234/** * Thread state for a terminated thread. * The thread has completed execution. */","categories":[{"name":"Java","slug":"Java","permalink":"https://www.huzhengxing.com/categories/Java/"}],"tags":[{"name":"Java线程","slug":"Java线程","permalink":"https://www.huzhengxing.com/tags/Java%E7%BA%BF%E7%A8%8B/"}]},{"title":"Activemq","slug":"Activemq学习","date":"2019-11-21T12:08:48.000Z","updated":"2019-12-14T07:52:31.654Z","comments":true,"path":"2019/11/21/Activemq学习/","link":"","permalink":"https://www.huzhengxing.com/2019/11/21/Activemq%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1. 什么是Activemq1.1 什么是mq维基百科： 在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。 消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。这句话把消息队列说明的很清楚。顾名思义就是保存消息的队列。 1.2 消息模型 P2P(Point-to-Point) 点对点模式，就是生产者发布的消息，只能被一个消费者消费。 ​ Producer发布一条消息，ConsumerA和ConsumerB只能有一个能接收消息，消息在队列中被消费掉，就没有了。 Pub/Sub(Publish/Subscribe) 发布订阅模式，生产者发布的消息，可以被所有的消费者消费。 Producer发布一条消息,ConsumerA和ConsumerB都能接收到消息。 1.2 什么是Activemq Apache ActiveMQ是Apache软件基金会所研发的开放源码消息中间件；由于ActiveMQ是一个纯Java程序，因此只需要操作系统支持Java虚拟机，ActiveMQ便可执行。 2. 为什么使用Activemqmq的优点有很多，能觉得很多问题。下面是我使用中解决的一些问题 2.1 数据同步在我们日常开发中，经常会对接到其他的公司。比如用户信息的同步，总不能别人的用户信息修改了，我们这里还是用之前的。这样肯定会出问题的。 解决方案 定时任务 定时查询变更数据,这样的缺点就是，数据不能实时同步。除非间隔时间很短，那也太吃服务性能了。 通过mq 每次变更数据时，发布到消息队列，让别人来订阅，这样别人可以实时的更新数据。 2.2 异步处理请求直接用一个用户短信登录例子来说明 一般发短信，通常都是调用第三方服务。如果使用同步请求的方式，那样会很慢。所以可以通过消息队列，把需要发送的消息放到队列里，异步的处理。这样接口的响应就会很快。 3. 怎么使用Activemq Springboot + Activemq","categories":[{"name":"Activemq","slug":"Activemq","permalink":"https://www.huzhengxing.com/categories/Activemq/"}],"tags":[{"name":"Activemq","slug":"Activemq","permalink":"https://www.huzhengxing.com/tags/Activemq/"},{"name":"消息队列","slug":"消息队列","permalink":"https://www.huzhengxing.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"mq","slug":"mq","permalink":"https://www.huzhengxing.com/tags/mq/"}]},{"title":"Springboot+Activemq","slug":"Springboot+Activemq","date":"2019-11-21T12:08:00.000Z","updated":"2019-11-21T11:56:16.115Z","comments":true,"path":"2019/11/21/Springboot+Activemq/","link":"","permalink":"https://www.huzhengxing.com/2019/11/21/Springboot+Activemq/","excerpt":"","text":"1. Mac搭建Activemq 安装brew,如果已经安装了直接跳过 1ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" 安装Activemq 1brew install activemq 启动Activemq 1activemq start 访问地址http://localhost:8161/ 默认账号密码都是:admin 问题: 如果直接在官网下载linux版activemq,运行会报错。 这个问题应该是mac os 10.15版本的原因。所以只能通过brew来安装。 2. 生产者代码地址 2.1 pom导入12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2 yml配置注意这里的地址是:tcp://127.0.0.1:61616,和后台访问的地址不一样。 1234567891011121314server: port: 20001 servlet: context-path: /spring: application: name: activemq-consumer activemq: broker-url: tcp://127.0.0.1:61616 user: admin password: adminqueue: queue 2.3 创建一个队列123456789101112@Configurationpublic class QueueConfig &#123; @Value(\"$&#123;queue&#125;\") private String queue; @Bean public Queue logQueue() &#123; return new ActiveMQQueue(queue); &#125;&#125; 2.4 发布消息12345678910111213141516171819@Component@EnableScheduling@Slf4jpublic class Producer &#123; @Autowired private JmsMessagingTemplate jmsMessagingTemplate; @Autowired private Queue queue; @Scheduled(fixedDelay = 10000) public void send() &#123; String message = \"发布消息:\" + System.currentTimeMillis(); log.info(message); jmsMessagingTemplate.convertAndSend(queue,message); &#125;&#125; 3. 消费者代码地址 3.1 pom导入和生产者导入的依赖一样 12345678910111213141516171819&lt;dependencies&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 3.2 yml配置123456789101112131415server: port: 20000 servlet: context-path: /spring: application: name: activemq-consumer activemq: broker-url: tcp://127.0.0.1:61616 user: admin password: adminqueue: queue 3.3 接收消息12345678@Slf4j@Componentpublic class Consumer &#123; @JmsListener(destination = \"$&#123;queue&#125;\") public void receive(String msg) &#123; log.info(\"接收数据:&#123;&#125;\",msg); &#125;&#125;","categories":[{"name":"Activemq","slug":"Activemq","permalink":"https://www.huzhengxing.com/categories/Activemq/"}],"tags":[{"name":"Activemq","slug":"Activemq","permalink":"https://www.huzhengxing.com/tags/Activemq/"},{"name":"mq","slug":"mq","permalink":"https://www.huzhengxing.com/tags/mq/"},{"name":"Springboot","slug":"Springboot","permalink":"https://www.huzhengxing.com/tags/Springboot/"}]},{"title":"MySql备份方式","slug":"MySql备份处理","date":"2019-11-16T14:09:37.000Z","updated":"2019-11-18T02:43:55.857Z","comments":true,"path":"2019/11/16/MySql备份处理/","link":"","permalink":"https://www.huzhengxing.com/2019/11/16/MySql%E5%A4%87%E4%BB%BD%E5%A4%84%E7%90%86/","excerpt":"","text":"1. Windows server定时备份 创建bat文件 编辑bat文件,加入执行脚本 123@echo offset \"Ymd=%date:~,4%%date:~5,2%%date:~8,2%\"[\"C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin\\mysqldump\"] --opt -u [root] --password=[123456] [dbname] &gt; C:\\mysql_backup\\[dbname]_%Ymd%.sql@echo on ​ []里面都是需要按照个人修改 “C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin\\mysqldump” 按照MySql的mysqldump文件所在位置 root 用户名 123456 密码 dbname 数据库名称 配置好后直接保存，点击运行，如果生成一个sql文件。那就成功了 添加window任务计划，执行该脚本。","categories":[{"name":"MySql","slug":"MySql","permalink":"https://www.huzhengxing.com/categories/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://www.huzhengxing.com/tags/MySql/"},{"name":"备份","slug":"备份","permalink":"https://www.huzhengxing.com/tags/%E5%A4%87%E4%BB%BD/"}]},{"title":"一次数据的误删除","slug":"一次数据的误删除","date":"2019-11-16T12:08:48.000Z","updated":"2019-11-18T02:09:26.840Z","comments":true,"path":"2019/11/16/一次数据的误删除/","link":"","permalink":"https://www.huzhengxing.com/2019/11/16/%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%AF%E5%88%A0%E9%99%A4/","excerpt":"","text":"1. 场景​ 今天在把测试数据库的表更新到正式数据库时，因为直接用了navicat，所以就直接把表复制过去，非常方便。但是，同时也把测试数据库里面的数据复制到了正式数据库，没办法只能手动删除。好了，精彩时刻来了，由于两个表名字有点相似，居然删错表里面的数据，一个是canteen_recharge_record，我新添加的库是canteen_subscribe_record，一个单词之差，看走眼了。直接把canteen_recharge_record里面的数据全删了。瞬间头皮发麻。 ​ 2. 解决过程​ 第一反应，就是去数据库查看备份的数据，虽然只有一天一次备份。起码还可以把今天之前的数据能找回来。一打开备份的文件夹，一脸懵逼，从9月29号之后。数据库居然没有备份了，都是1KB。我了个去。什么情况？再仔细一想，由于公司人员增加，之前就是有人乱改了数据库，所以现在统一把账号，密码修改了，分为正式的和测试，然而，备份配置的账号密码，还是之前的，瞬间完蛋。 ​ 没办法，那就只能直接百度，Google，一顿搜索，各种尝试。结果就是，针对于MySql恢复数据,基本上就是通过备份，或者通过binlog，这两个我都没有。之间还在淘宝搜索，还真有恢复的。找了一家打电话联系后说了一下情况，直接说，无法恢复。 ​ 一个喜欢贼习惯看吾爱破解的同事，想出了一个办法。说通过恢复文件的方式，因为数据库数据最终还是保存在本地磁盘，可以通过文件恢复，感觉还是有点道理。一顿操作后，发现都是需要花钱的恢复文件，而且一般的恢复文件都是恢复删除的文件，我们在本地数据库测试的时候发现，删除表的数据库，只是修改了文件，并没有删除。除非能让数据回滚到某一个时间段。 ​ 因为我们是用的阿里云服务器，所以想到了阿里快照，因为我们之前服务器被黑过，所以了解到了云服务器的快照。登录阿里云之后，发现就是上次快照了一次，尴尬。 ​ 事到至此，只能先和客户那边沟通。沟通之后，发现这部分的数据不是特别重要，只是充值记录。偶尔为了，确认一下比人充值了没，才会去看下。瞬间安心了好多。 ​ 但是，部分数据库还是得找回来。只能用一个死办法了，通过日志来找回数据库。花花的好几个G的日志文件。 ​ 哎，真的是手贱，太粗心了。 3. 吸取教训 数据库的备份做好，而且确保能用，最好能偶尔查看一下。这里的备份中间出问题，就是，没去看是否备份成功。 服务器做好快照，不仅是数据库的问题，服务器也是一样，万一不小心输入了rm rf /*,那是真的GG了 操作正式数据库之前，一定得手动备份一次。以免误操作数据。","categories":[{"name":"个人经历","slug":"个人经历","permalink":"https://www.huzhengxing.com/categories/%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://www.huzhengxing.com/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://www.huzhengxing.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Git使用命令","slug":"Git使用命令","date":"2019-11-14T02:09:37.000Z","updated":"2019-11-18T02:09:23.601Z","comments":true,"path":"2019/11/14/Git使用命令/","link":"","permalink":"https://www.huzhengxing.com/2019/11/14/Git%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Git相关的操作命令 1. 下载代码github代码下载到本地。 1git clone https://github.com/huzhengxing/spring-cloud-demo.git 2. 拉取代码远程仓库代码，更新到本地。 1git pull 3. 上传代码本地已经git commit文件上传的远程仓库。(先git pull,再git push) 1git push 4. 提交代码本地1git commit -m \"备注\" 5. 查看本地提交的代码1git status 6. 删除本地仓库代码已经git commit 的文件 1git rm -r --cached [fileName] 7. 查看分支1git branch 8. 创建分支1git branch [branchName] 9. 添加远程仓库远程已经创建仓库,本地代码同步到远程仓库。 1git remote add origin [远程地址] 10. 添加远程分支本地代码同步到远程仓库，添加分支，才能提交上传代码。 1git pull origin master","categories":[{"name":"Git","slug":"Git","permalink":"https://www.huzhengxing.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.huzhengxing.com/tags/Git/"}]},{"title":"Springboot整合Websocket","slug":"Springboot整合Websocket","date":"2019-11-13T02:09:37.000Z","updated":"2019-11-18T02:09:25.752Z","comments":true,"path":"2019/11/13/Springboot整合Websocket/","link":"","permalink":"https://www.huzhengxing.com/2019/11/13/Springboot%E6%95%B4%E5%90%88Websocket/","excerpt":"","text":"springboot整合websocket,实现即使通讯的一对一单聊。 1. 导入相关依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.komlin&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger2--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;version&gt;1.5.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;1.5.17.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这里用的是1.5.17.RELEASE版本的websocket,之前用了2.0.4RELEASE版本存在问题 2. 配置ServerEndpoint注入Spring将ServerEndpointExporter类注入到spring容器,处理@ServerEndpoint注解的实现类 12345678@Configurationpublic class WSConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter() &#123; return new ServerEndpointExporter(); &#125;&#125; 3. 实现类这里可以处理我们需要的逻辑,这里简单的实现了一个一对一单聊 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@ServerEndpoint(value = \"/websocket/&#123;userId&#125;\")@Slf4j@Componentpublic class WSController &#123; private static ConcurrentHashMap&lt;String, Session&gt; onlineUsers = new ConcurrentHashMap&lt;&gt;(); /** * 开始连接时，调用 * @param session * @param userId */ @OnOpen public void onOpen(Session session, @PathParam(\"userId\") String userId) &#123; log.info(\"进入:&#123;&#125;\",\"onOpen\"); log.info(\"userId:&#123;&#125;\",userId); if (onlineUsers.get(userId) != null ) &#123; sendMessage(session,\"您已经在线!\"); return; &#125; onlineUsers.put(userId,session); printOnlineUserSize(); &#125; /** * 关闭连接时调用 * @param session */ @OnClose public void onClose(Session session) &#123; onlineUsers.forEach((k,v) -&gt; &#123; if (v.getId().equals(session.getId())) &#123; log.info(\"有人下线了:&#123;&#125;\",k); onlineUsers.remove(k); &#125; &#125;); printOnlineUserSize(); log.info(\"进入:&#123;&#125;\",\"onClose\"); &#125; /** * 接收客户端的消息 * @param session * @param message */ @OnMessage public void onMessage(Session session,String message) &#123; log.info(\"进入:&#123;&#125;\",\"onMessage\"); log.info(\"message:&#123;&#125;\",message); Message messageObject = JsonUtils.jsonToPojo(message, Message.class); Session sessionOfFriend = onlineUsers.get(messageObject.getFriendUserId()); if (sessionOfFriend != null) &#123; sendMessage(sessionOfFriend,messageObject.getText()); &#125; &#125; /** * 报错时调用 * @param session * @param throwable */ @OnError public void onError(Session session,Throwable throwable) &#123; log.info(\"进入:&#123;&#125;\",\"onError\"); &#125; /** * 向客服端发送消息 * @param session * @param message */ private void sendMessage(Session session,String message) &#123; try &#123; session.getBasicRemote().sendText(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void printOnlineUserSize() &#123; log.info(\"当前在线人数:&#123;&#125;\",onlineUsers.size()); &#125;&#125;","categories":[{"name":"IM","slug":"IM","permalink":"https://www.huzhengxing.com/categories/IM/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.huzhengxing.com/tags/springboot/"},{"name":"websocket","slug":"websocket","permalink":"https://www.huzhengxing.com/tags/websocket/"},{"name":"im","slug":"im","permalink":"https://www.huzhengxing.com/tags/im/"}]}]}